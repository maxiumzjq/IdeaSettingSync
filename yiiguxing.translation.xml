<application>
  <component name="AppStorage">
    <histories>
      <item value="annual Leave" />
      <item value="import Data" />
      <item value="upload 1" />
      <item value="BATCH COUNT" />
      <item value="ATCH COUNTäº†" />
      <item value="Importable Entity com.ot.oa.dto.admin.ListAnnualLeaveDTO should implements interface Importable" />
      <item value="string Date Pattern" />
      <item value="notification Notice" />
      <item value="Allocates a Date object and initializes it so that it represents the time at which it was allocated, measured to the nearest millisecond. See Also: System.currentTimeMillis()" />
      <item value="Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured." />
      <item value="history" />
      <item value="Result" />
      <item value="un Read All Total" />
      <item value="un Read All Count" />
      <item value="un Read Total Count" />
      <item value="cluster Node" />
      <item value="search Word" />
      <item value="key Word" />
      <item value="search Attach" />
      <item value="text" />
      <item value="combine Result Map" />
      <item value="Specifying types in search requests is deprecated" />
      <item value="require Field Match" />
      <item value="ith Pageable(" />
      <item value="with Highlight Builder" />
      <item value="with Highlight Fields" />
      <item value="No property summary found for type NormalIndexData!" />
      <item value="Index Datasource View" />
      <item value="index View List" />
      <item value="official Duties Id" />
      <item value="al Duties Id;" />
      <item value="PUBLIC DOC RECEIVE" />
      <item value="@implSpec The default implementation is equivalent to, for this {@code map}: &lt;pre&gt; {@code for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) action.accept(entry.getKey(), entry.getValue()); }&lt;pre&gt; The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties. @param action The action to be performed for each entry @throws NullPointerException if the specified action is null @throws ConcurrentModificationException if an entry is found to be removed during iteration @since 1.8" />
      <item value="Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller." />
      <item value="the entity clazz used for property mapping and index name extraction" />
      <item value="QueryTests {" />
      <item value="the index where to update the records , must not be {@literal null}" />
      <item value="query defining the update, must not be {@literal" />
      <item value="Request to update some documents. That means you can't change their type, id, index, or anything like that. This implements CompositeIndicesRequest but in a misleading way. Rather than returning all the subrequests that it will make it tries to return a representative set of subrequests. This is best-effort but better than {@linkplain ReindexRequest} because scripts can't change the destination index and things." />
      <item value="The language for this {@link Script} if the {@link ScriptType} is {@link ScriptTypeINLINE}. For {@link ScriptTypeSTORED} scripts this should be null, but can be specified to access scripts stored as part of the stored scripts deprecated API." />
      <item value="lang" />
      <item value="The entity class, must be annotated with" />
      <item value="query defining the objects" />
      <item value="Index Query" />
      <item value="query defining the objects @param clazz The entity class, must be annotated with {@link org.springframework.data.elasticsearch.annotations.Document} @return response with detailed information" />
      <item value="indices" />
      <item value="Delete By Query Request" />
      <item value="Creates a new DeleteByQueryRequest that uses scrolling and bulk requests to delete all documents matching the query. This can have performance as well as visibility implications. Delete-by-query now has the following semantics: it's non-atomic, a delete-by-query may fail at any time while some documents matching the query have already been deleted it's syntactic sugar, a delete-by-query is equivalent to a scroll search and corresponding bulk-deletes by ID it's executed on a point-in-time snapshot, a delete-by-query will only delete the documents that are visible at the point in time the delete-by-query was started, equivalent to the scroll API it's consistent, a delete-by-query will yield consistent results across all replicas of a shard it's forward-compatible, a delete-by-query will only send IDs to the shards as deletes such that no queries are stored in the transaction logs that might not be supported in the future. it's results won't be visible until the index is refreshed." />
      <item value="Validation Failed: 1: query is missing;" />
      <item value="Delete the one object with provided id." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="82" />
        <entry key="ENGLISH" value="83" />
        <entry key="FILIPINO" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1652944522989" />
  </component>
</application>