<application>
  <component name="AppStorage">
    <histories>
      <item value="No property summary found for type NormalIndexData!" />
      <item value="Index Datasource View" />
      <item value="index View List" />
      <item value="official Duties Id" />
      <item value="al Duties Id;" />
      <item value="PUBLIC DOC RECEIVE" />
      <item value="@implSpec The default implementation is equivalent to, for this {@code map}: &lt;pre&gt; {@code for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) action.accept(entry.getKey(), entry.getValue()); }&lt;pre&gt; The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties. @param action The action to be performed for each entry @throws NullPointerException if the specified action is null @throws ConcurrentModificationException if an entry is found to be removed during iteration @since 1.8" />
      <item value="Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller." />
      <item value="the entity clazz used for property mapping and index name extraction" />
      <item value="QueryTests {" />
      <item value="the index where to update the records , must not be {@literal null}" />
      <item value="query defining the update, must not be {@literal" />
      <item value="Request to update some documents. That means you can't change their type, id, index, or anything like that. This implements CompositeIndicesRequest but in a misleading way. Rather than returning all the subrequests that it will make it tries to return a representative set of subrequests. This is best-effort but better than {@linkplain ReindexRequest} because scripts can't change the destination index and things." />
      <item value="The language for this {@link Script} if the {@link ScriptType} is {@link ScriptTypeINLINE}. For {@link ScriptTypeSTORED} scripts this should be null, but can be specified to access scripts stored as part of the stored scripts deprecated API." />
      <item value="lang" />
      <item value="The entity class, must be annotated with" />
      <item value="query defining the objects" />
      <item value="Index Query" />
      <item value="query defining the objects @param clazz The entity class, must be annotated with {@link org.springframework.data.elasticsearch.annotations.Document} @return response with detailed information" />
      <item value="indices" />
      <item value="Delete By Query Request" />
      <item value="Creates a new DeleteByQueryRequest that uses scrolling and bulk requests to delete all documents matching the query. This can have performance as well as visibility implications. Delete-by-query now has the following semantics: it's non-atomic, a delete-by-query may fail at any time while some documents matching the query have already been deleted it's syntactic sugar, a delete-by-query is equivalent to a scroll search and corresponding bulk-deletes by ID it's executed on a point-in-time snapshot, a delete-by-query will only delete the documents that are visible at the point in time the delete-by-query was started, equivalent to the scroll API it's consistent, a delete-by-query will yield consistent results across all replicas of a shard it's forward-compatible, a delete-by-query will only send IDs to the shards as deletes such that no queries are stored in the transaction logs that might not be supported in the future. it's results won't be visible until the index is refreshed." />
      <item value="Validation Failed: 1: query is missing;" />
      <item value="Delete the one object with provided id." />
      <item value="with" />
      <item value="ot" />
      <item value="the document ot delete" />
      <item value="sample" />
      <item value="Index Coordinates" />
      <item value="with Id" />
      <item value="No ParameterResolver registered for parameter" />
      <item value="org.junit.jupiter.api.extension.ParameterResolutionException: No ParameterResolver registered for parameter [org.springframework.data.elasticsearch.core.ElasticsearchOperations elasticsearchOperations] in constructor [com.zjq.elasticsearch.ElasticsearchApplicationTests(org.springframework.data.elasticsearch.core.ElasticsearchOperations,org.elasticsearch.client.RestHighLevelClient)]." />
      <item value="if nothing needs to be customized" />
      <item value="options" />
      <item value="Index a document using the Index API." />
      <item value="High level REST client that wraps an instance of the low level {@link RestClient} and allows to build requests and read responses. The {@link RestClient} instance is internally built based on the provided {@link RestClientBuilder} and it gets closed automatically when closing the {@link RestHighLevelClient} instance that wraps it. &lt;p&gt; In case an already existing instance of a low-level REST client needs to be provided, this class can be subclassed and the {@link RestHighLevelClient(RestClient, CheckedConsumer, List)} constructor can be used. &lt;p&gt; This class can also be sub-classed to expose additional client methods that make use of endpoints added to Elasticsearch through plugins, or to add support for custom response sections, again added to Elasticsearch through plugins. &lt;p&gt; The majority of the methods in this class come in two flavors, a blocking and an asynchronous version (e.g. {@link search(SearchRequest, RequestOptions)} and {@link searchAsync(SearchRequest, RequestOptions, ActionListener)}, where the later takes an implementation of an {@link ActionListener} as an argument that needs to implement methods that handle successful responses and failure scenarios. Most of the blocking calls can throw an {@link IOException} or an unchecked {@link ElasticsearchException} in the following cases: &lt;ul&gt; &lt;li&gt;an {@link IOException} is usually thrown in case of failing to parse the REST response in the high-level REST client, the request times out or similar cases where there is no response coming back from the Elasticsearch server&lt;li&gt; &lt;li&gt;an {@link ElasticsearchException} is usually thrown in case where the server returns a 4xx or 5xx error code. The high-level client then tries to parse the response body error details into a generic ElasticsearchException and suppresses the original {@link ResponseException}&lt;li&gt; &lt;ul&gt;" />
      <item value="IndexQuery Builder" />
      <item value="Immutable Value object encapsulating index name(s) and index type(s). Type names are supported but deprecated as Elasticsearch does not support types anymore." />
      <item value="current Has Read" />
      <item value="ad)" />
      <item value="Previous Or Next User Mail Id DTO" />
      <item value="Previous Or Next User" />
      <item value="Previous Or Next User Mail Id" />
      <item value="Next User Mail Id" />
      <item value="Previous" />
      <item value="list Previous Or Next User Mail Id" />
      <item value="le" />
      <item value="business Data Id" />
      <item value="update listLeader request param" />
      <item value="Leader Form" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="56" />
        <entry key="ENGLISH" value="57" />
        <entry key="FILIPINO" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1651051138103" />
  </component>
</application>